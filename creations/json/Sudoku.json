{
  "name": "Sudoku",
  "html": "<!DOCTYPE html>\n<html lang=\"en-us\">\n    <head>\n        <meta charset=\"utf-8\" />\n        <meta name=\"viewport\" content=\"width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no\" />\n        <title>Sudoku - Red Dragon Web Design</title>\n    </head>\n    <body>\n        <table>\n            <tr>\n                <td width=\"100vw\" align=\"center\">\n                    <h1>SUDOKU</h1>\n                </td>\n            </tr>\n            <tr>\n                <td align=\"center\">\n                    <div id=\"body\" class=\"body\">\n                        <p>Erzeugt bei Bedarf einfach zu lösende Rätsel. Löst Rätsel extrem schnell, sogar Rätsel, bei denen andere Algorithmen eine Zeitüberschreitung verursachen, indem eine Kombination aus Iteration und Rekursion verwendet wird. Es ist unmöglich, eine falsche Nummer einzugeben.</p>\n                        <div>\n                            <button id=\"new\" class=\"done\" title=\"Generiere ein zufälliges, leicht zu lösendes Sudoku.\">Neu</button>\n                            <button id=\"hint\" class=\"done\" title=\"Suche nach einfach zu lösenden, aber noch ungelösten Quadraten. Wenn keine einfach zu lösenden Quadrate existieren, wird nichts hervorgehoben.\">Hinweis</button>\n                            <button id=\"validate\" class=\"done\" title=\"Löse das Rätsel mit einem rekursiven Algorithmus. Funktioniert bei jedem Sudoku, unabhängig vom Schwierigkeitsgrad. Erkennt kaputte Rätsel.\">Lösen</button>\n                            <button id=\"import\" class=\"done\" title=\"Importieren Sie ein Sudoku. Es muss eine 81-stellige Zeichenfolge eingegeben werden. Sie können leere Quadrate mit 0 darstellen.\">Importieren</button>\n                            <button id=\"restart\" class=\"done\" title=\"Vom Benutzer eingegebene Lösungen löschen. Das Puzzle auf seinen ursprünglichen Importzustand zurücksetzen.\">Neustart</button>\n                            <button id=\"propagate\">Propagieren</button>\n                            <span id=\"algorithm\">\n                                <span></span>\n                            </span>\n                        </div>\n                        <div>\n                            <select id=\"puzzle-picker\">\n                                <option value=\"_________________________________________________________________________________\">[Leeres Brett]</option>\n                                <option value=\"custom_30\">[Neues Puzzle sehr leicht]</option>\n                                <option value=\"custom_35\">[Neues Puzzle leicht]</option>\n                                <option value=\"custom_40\">[Neues Puzzle mittel]</option>\n                                <option value=\"custom_45\">[Neues Puzzle schwer]</option>\n                                <option value=\"custom_50\">[Neues Puzzle sehr schwer]</option>\n                                <option value=\"1................................................................................\">Testing - Propagate</option>\n                                <option value=\"123.56789467......58.......6........7........8.................2........3........\">Testing - Process Of Elimination</option>\n                                <option value=\".8.165427145372968726984135871296354964531782532847691213759846497628513658413279\">Testing - Solution Count 1</option>\n                                <option value=\"38.16.4.714.37.96872698.13587.2963549645.17825328476.1213.59846497.285136584.3279\">Testing - Solution Count 2</option>\n                                <option value=\"1....7....3..2...8..96..5....53..9...1..8...26....4...3......1..41.....7..7...3..\">Testing - 20 Solutions</option>\n                                <option value=\"1.........3..2...8..96..5....53..9...1..8...26....4...3......1..41.....7..7...3..\">Testing - 500+ Solutions</option>\n                                <!-- don't use https://www.sudokuweb.org/, their generator makes unsolveable puzzles -->\n                                <!-- from https://www.sudokuwiki.org/ -->\n                                <option value=\".8.1....7....7.96..269..13....29.3.496.....825.2.47....13..984..97.2....6....3.7.\">Beginner</option>\n                                <option value=\"24..7..38.....6.7.3...4.6....8.2.7..1.......6..7.3.4....4.8...986.4.....91..6...2\">Intermediate - Last Number In Row, Col, & Box</option>\n                                <option value=\"246.7..38...3.6.7437..4.6....8.2.7..1.......6..7.3.4....4.8..6986.4....791..6..42\">Intermediate - Naked Single</option>\n                                <option value=\".....4.284.6.....51...3.6.....3.1....87...14....7.9.....2.1...39.....5.767.4.....\">Intermediate - Hidden Singles</option>\n                                <option value=\"4......38..2..41....53..24..7.6.9..4.2.....7.6..7.3.9..57..83....39..4..24......9\">Intermediate - Naked Pairs/Triples</option>\n                                <option value=\".........9.46.7....768.41..3.97.1.8...8...3...5.3.87.2..75.261....4.32.8.........\">Intermediate - Hidden Pairs/Triples</option>\n                                <option value=\"....3..86....2.........85..371....949.......54....76..2..7..8...3...5...7....4.3.\">Intermediate - Naked/Hidden Quads</option>\n                                <option value=\".1.9.36......8....9.....5.7..2.1.43....4.2....64.7.2..7.1.....5....3......56.1.2.\">Intermediate - Pointing Pairs</option>\n                                <option value=\".16..78.3...8......7...1.6..48...3..6.......2..9...65..6.9...2......2...9.46..51.\">Intermediate - Box/Line Reduction</option>\n                                <option value=\"1.....5694.2.....8.5...9.4....64.8.1....1....2.8.35....4.5...1.9.....4.2621.....5\">Advanced - X-Wing</option>\n                                <option value=\"..7..36...39...8...2..1..5..4.1..3.....367.....3..8.6..9..7..2...4...13...86..9..\">Advanced - Simple Coloring</option>\n                                <option value=\"9...4.......6...31.2.....9....7...2...29356...7...2....6.....7351...9.......8...9\">Advanced - Y-Wing</option>\n                                <option value=\"5...1...3..6..3..2..32.......23...76....5....19...75.......94..2..8..6..9...4...5\">Advanced - Swordfish</option>\n                                <option value=\".9...17..5..2....8....3.2...7...496.2...6...5.697...3...8.9....7....3..9..38...4.\">Advanced - XYZ Wing</option>\n                                <!-- from https://github.com/attractivechaos/plb/blob/master/sudoku/sudoku.txt -->\n                                <option value=\"..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9\">Insane Puzzle #1 - 25s (Hidden Singles)</option>\n                                <option value=\".......12........3..23..4....18....5.6..7.8.......9.....85.....9...4.5..47...6...\">Insane Puzzle #2 - 2s</option>\n                                <option value=\".2..5.7..4..1....68....3...2....8..3.4..2.5.....6...1...2.9.....9......57.4...9..\">Insane Puzzle #3 - 0.2s</option>\n                                <option value=\"........3..1..56...9..4..7......9.5.7.......8.5.4.2....8..2..9...35..1..6........\">Insane Puzzle #4 - 7s (1 Hidden Single, Then Exocet)</option>\n                                <option value=\"12.3....435....1....4........54..2..6...7.........8.9...31..5.......9.7.....6...8\">Insane Puzzle #5 - 2s</option>\n                                <option value=\"1.......2.9.4...5...6...7...5.9.3.......7.......85..4.7.....6...3...9.8...2.....1\">Insane Puzzle #6 - 2s</option>\n                                <option value=\".......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7.....\">Insane Puzzle #7 - 1s</option>\n                                <option value=\"12.3.....4.....3....3.5......42..5......8...9.6...5.7...15..2......9..6......7..8\">Insane Puzzle #8 - 9s (Exocet)</option>\n                                <option value=\"..3..6.8....1..2......7...4..9..8.6..3..4...1.7.2.....3....5.....5...6..98.....5.\">Insane Puzzle #9 - 0.3s</option>\n                                <option value=\"1.......9..67...2..8....4......75.3...5..2....6.3......9....8..6...4...1..25...6.\">Insane Puzzle #10 - 2s</option>\n                                <option value=\"..9...4...7.3...2.8...6...71..8....6....1..7.....56...3....5..1.4.....9...2...7..\">Insane Puzzle #11 - 2s</option>\n                                <option value=\"....9..5..1.....3...23..7....45...7.8.....2.......64...9..1.....8..6......54....7\">Insane Puzzle #12 - 7s</option>\n                                <option value=\"4...3.......6..8..........1....5..9..8....6...7.2........1.27..5.3....4.9........\">Insane Puzzle #13 - 33s (1 Hidden Single, then Bowman's Bingo)</option>\n                                <option value=\"7.8...3.....2.1...5.........4.....263...8.......1...9..9.6....4....7.5...........\">Insane Puzzle #14 - 4s</option>\n                                <option value=\"3.7.4...........918........4.....7.....16.......25..........38..9....5...2.6.....\">Insane Puzzle #15 - 1s</option>\n                                <option value=\"........8..3...4...9..2..6.....79.......612...6.5.2.7...8...5...1.....2.4.5.....3\">Insane Puzzle #16 - 7s (1 Hidden Single, then stuck)</option>\n                                <option value=\".......1.4.........2...........5.4.7..8...3....1.9....3..4..2...5.1........8.6...\">Insane Puzzle #17 - 0.2s</option>\n                                <option value=\".......12....35......6...7.7.....3.....4..8..1...........12.....8.....4..5....6..\">Insane Puzzle #18 - 20s (Hidden Singles)</option>\n                                <option value=\"1.......2.9.4...5...6...7...5.3.4.......6........58.4...2...6...3...9.8.7.......1\">Insane Puzzle #19 - 4s</option>\n                                <option value=\".....1.2.3...4.5.....6....7..2.....1.8..9..3.4.....8..5....2....9..3.4....67.....\">Insane Puzzle #20 - 0.6s</option>\n                                <option value=\"8..........36......7..9.2...5...7.......457.....1...3...1....68..85...1..9....4..\">Insane Puzzle #21 - 5s</option>\n                                <option value=\"......6.5...3...9..8...4..1.4..2.97...........31.8..6.9..6...2..1...7...5.4......\">Riddle of Sho - 0.2s</option>\n                                <option value=\"1....7.9..3..2...8..96..5....53..9...1..8...26....4...3......1..41.....7..7...3..\">Escargot - 0.1s</option>\n                                <option value=\".....1..2..3....4..5..6.7.....8...7...7..38..9...5...1..6.8.2...4.6....72....9.6.\">Shining Mirror - 0.9s</option>\n                                <option value=\"8..........36......7..9.2...5...7.......457.....1...3...1....68..85...1..9....4..\">Arto Inkala - 5s</option>\n                                <option value=\"........1.......23..4..5......1.........3.6....7...58.....67....1...4...52.......\">Only 17 Numbers - 8s</option>\n                            </select>\n                        </div>\n                        <table id=\"sudoku\"></table>\n                        <div class=\"input-numbers\"></div>\n                        <input id=\"string-box\" type=\"text\">\n                        <p>See the logical solving steps using the <a id=\"sudoku-wiki-link\">Sudoku Wiki Solver</a></p>\n                        <p>Want to report a bug or request a feature? <a href=\"https://github.com/RedDragonWebDesign/Sudoku/issues\">Create an issue</a> on our GitHub.</p>\n                        <p id=\"console\">\n                            <textarea></textarea>\n                        </p>\n                    </div>\n                </td>\n            </tr>\n        </table>\n        <div class=\"final\"></div>\n        <div id=\"finale\" class=\"final\"></div>\n        <script>\n            var firstStartup = 1;\n        </script>\n    </body>\n</html>",
  "js": "// Copyright https://www.RedDragonWebDesign.com/\n// Permission required to use or copy code. All rights reserved.\n(function() {\n    \"use strict\";\n    class SudokuBoard {\n        constructor() {\n            this.blankBoard = SudokuBoard.getBlankBoard();\n            this.board = SudokuBoard.getBlankBoard();\n            this.originalBoard = SudokuBoard.getBlankBoard();\n        }\n        static getBlankBoard() {\n            let board = [];\n            for (let i = 0; i < boardSize; i++) {\n                board[i] = [];\n                for (let j = 0; j < boardSize; j++) board[i][j] = 0;\n            }\n            return board;\n        }\n        // This is only meant for use by solveRecursively. Faster than parseString\n        // Everything else should use parseString. parseString performs more data validation.\n        setBoard(board) {\n            this.board = board;\n        }\n        static cloneBoard(board) {\n            let array = Helper.createArray([boardSize, boardSize]);\n            for (let i = 0; i < boardSize; i++) array[i] = [...board[i]];\n            return array;\n        }\n        // returns if board changed or not\n        parseString(boardString, setOriginalBoard = true) {\n            const oldBoard = SudokuBoard.cloneBoard(this.board);\n            if (!boardString || !boardString.match(new RegExp(\"^[0-\" + boardSize + \"*_.]{\" + boardGrid + \"}$\", \"m\"))) return false;\n            // TODO: foreach getBoardSquares\n            for (let row = 0; row < boardSize; row++) {\n                for (let column = 0; column < boardSize; column++) {\n                    let char = boardString.charAt(row * boardSize + column);\n                    \"123456789\".indexOf(char) === -1 && (char = 0);\n                    this.board[row][column] = parseInt(char);\n                }\n            }\n            if (!this.puzzleIsValid()) return (this.board = SudokuBoard.cloneBoard(oldBoard), false);\n            setOriginalBoard && this.setOriginalBoard(this.board);\n            return true;\n        }\n        getBoard() {\n            return this.board;\n        }\n        getString() {\n            let str = \"\";\n            for (let row = 0; row < boardSize; row++) for (let col = 0; col < boardSize; col++) str += this.board[row][col];\n            return str;\n        }\n        // making this its own method to help with debugging\n        setOriginalBoard(obj) {\n            this.originalBoard = SudokuBoard.cloneBoard(obj);\n        }\n        restartPuzzle() {\n            this.board = SudokuBoard.cloneBoard(this.originalBoard);\n        }\n        makeMove(row, col, value) {\n            \"123456789\".indexOf(value) === -1 && (value = 0);\n            this.board[row][col] = parseInt(value);\n        }\n        numberInBox(candidate, square) {\n            const [row, col] = [square.getRow(), square.getCol()];\n            // find top left corner of box\n            const [rowOffset, colOffset] = [Math.floor(row / boardSquare) * boardSquare, Math.floor(col / boardSquare) * boardSquare];\n            // iterate around 3x3 area\n            for (let i = 0 + rowOffset; i < boardSquare + rowOffset; i++) for (let j = 0 + colOffset; j < boardSquare + colOffset; j++) if (this.board[i][j] === candidate) return true;\n            return false;\n        }\n        getSquaresInRow(row) {\n            let squares = [];\n            for (let i = 0; i < boardSize; i++) squares.push(new SudokuSquare(row, i, this.board[row][i]));\n            return squares;\n        }\n        getSquaresInColumn(col) {\n            let squares = [];\n            for (let i = 0; i < boardSize; i++) squares.push(new SudokuSquare(i, col, this.board[i][col]));\n            return squares;\n        }\n        getAllSquares() {\n            let squares = [];\n            for (let i = 0; i < boardGrid; i++) squares.push(new SudokuSquare(Math.floor(i / boardSize), i % boardSize, this.board[Math.floor(i / boardSize)][i % boardSize]));\n            return squares;\n        }\n        getSquare(row, col) {\n            return new SudokuSquare(row, col, this.board[row][col]);\n        }\n        getAllBoxes() {\n            let squares = [], i, j;\n            for (i = 0; i < boardSquare; i++) for (j = 0; j < boardSquare; j++) squares.push(new SudokuSquare(i * boardSquare, j * boardSquare, this.board[i * boardSquare][j * boardSquare]));\n            return squares;\n        }\n        // TODO: consider splitting the below code into a SudokuSolver class\n        // I haven't done it yet because I'd have to pass a board variable around. That's a lot of code re-writing. Not sure it's worth it.\n        puzzleIsValid() {\n            try { this.fullHouse(false, false); }\n            catch { return false; }\n            return true;\n        }\n        isLegalMove(row, col, value, checkForNonNumbers = true) {\n            if (checkForNonNumbers && !value.toString().match(new RegExp(\"^[1-\" + boardSize + \"]$\", \"m\"))) return false;\n            value = parseInt(value);\n            for (let i = 0; i < boardSize; i++) if (value === this.board[row][i] || value === this.board[i][col] || value === this.board[(Math.floor(row / boardSquare) * boardSquare + Math.floor(i / boardSquare))][(Math.floor(col / boardSquare) * boardSquare + i % boardSquare)]) return false;\n            return true;\n        }\n        solveLogically() {\n            this.solveUsingAllTechniques();\n            return this.puzzleIsSolved() ? true : false;\n        }\n        getHint() {\n            return this.solveUsingAllTechniques(true);\n        }\n        solveUsingAllTechniques(hintMode = false) {\n            let hintSquare;\n            let lastHintSquare = false;\n            // Need to keep looping, trying the techniques from easiest to hardest.\n            // If a technique solves a square, restart the loop.\n            // If no techniques can solve the current square, end the loop.\n            while (true) {\n                // TODO: have every square store its candidates, like sudokuwiki.org does\n                hintSquare = this.fullHouse(hintMode);\n                if (hintSquare && hintMode) return hintSquare;\n                if (hintSquare != lastHintSquare) {\n                    lastHintSquare = hintSquare;\n                    continue;\n                }\n                hintSquare = this.boxXray(hintMode);\n                if (hintSquare && hintMode) return hintSquare;\n                if (hintSquare != lastHintSquare) {\n                    lastHintSquare = hintSquare;\n                    continue;\n                }\n                // rowXray\n                // columnXray\n                // add other more complicated techniques here\n                break;\n            }\n            return hintSquare;\n        }\n        // Possibilities {1:true, 2:true, 3:true, 4:true, 5:true, 6:true, 7:true, 8:true, 9:true}\n        static squareIsSolved(possibilities) {\n            let trueCount = 0;\n            for (let i = 1; i <= boardSize; i++) {\n                possibilities[i] && trueCount++;\n                if (trueCount >= (boardSquare - 1)) return false;\n            }\n            if (trueCount === 1) return true;\n            return false;\n        }\n        // If 8 of 9 squares are filled in, fill in 9th square.\n        fullHouse(hintMode = false, modifyBoard = true) {\n            let possibilities = {};\n            let empty;\n            // check row\n            for (let row = 0; row < boardSize; row++) {\n                // bool array [true, true, true] is faster than list [1, 2, 3]\n                for (let i = 1; i <= boardSize; i++) possibilities[i] = true;\n                empty = 0;\n                for (let col = 0; col < boardSize; col++) {\n                    const value = this.board[row][col];\n                    value === 0 ? empty = col : possibilities[value] ? possibilities[value] = false : this.throwDuplicateNumberError();\n                }\n                if (SudokuBoard.squareIsSolved(possibilities)) {\n                    if (hintMode) return new SudokuSquare(row, empty);\n                    modifyBoard && (this.board[row][empty] = SudokuBoard.getTrueKey(possibilities));\n                }\n            }\n            // check column\n            for (let col = 0; col < boardSize; col++) {\n                for (let i = 1; i <= boardSize; i++) possibilities[i] = true;\n                empty = 0;\n                for (let row = 0; row < boardSize; row++) {\n                    const value = this.board[row][col];\n                    value === 0 ? empty = row : possibilities[value] ? possibilities[value] = false : this.throwDuplicateNumberError();\n                }\n                if (SudokuBoard.squareIsSolved(possibilities)) {\n                    if (hintMode) return new SudokuSquare(empty, col);\n                    modifyBoard && (this.board[empty][col] = SudokuBoard.getTrueKey(possibilities));\n                }\n            }\n            // check 3x3 grid\n            for (let row = 0; row < boardSize; row += boardSquare) {\n                for (let col = 0; col < boardSize; col += boardSquare) {\n                    for (let i = 1; i <= boardSize; i++) possibilities[i] = true;\n                    empty = [];\n                    const rowOffset = Math.floor(row / boardSquare) * boardSquare;\n                    const colOffset = Math.floor(col / boardSquare) * boardSquare;\n                    // iterate around 3x3 area\n                    for (let i = 0 + rowOffset; i < boardSquare + rowOffset; i++) {\n                        for (let j = 0 + colOffset; j < boardSquare + colOffset; j++) {\n                            const value = this.board[i][j];\n                            value === 0 ? empty = [i, j] : possibilities[value] ? possibilities[value] = false : this.throwDuplicateNumberError();\n                        }\n                    }\n                    if (SudokuBoard.squareIsSolved(possibilities)) {\n                        if (hintMode) return new SudokuSquare(empty[0], empty[1]);\n                        modifyBoard && (this.board[empty[0]][empty[1]] = SudokuBoard.getTrueKey(possibilities));\n                    }\n                }\n            }\n        }\n        // finds some hidden singles, using the cross hatching technique\n        // Try numbers 1-9. See if there are 2 row boxXrays, 2 column boxXrays, and that number is not present within 3x3.\n        boxXray(hintMode = false) {\n            // foreach 3x3 box on the board (method will grab the top left square of the box)\n            const boxes = this.getAllBoxes();\n            for (let square of boxes) {\n                // foreach candidate 1-9\n                for (let candidate = 1; candidate <= boardSize; candidate++) {\n                    // is number already in 3x3 box? continue;\n                    if (this.numberInBox(candidate, square)) continue;\n                    // boolean 3x3 array to track which cells in the box can possibly contain our candidate. default true.\n                    let tests = Helper.createArray([boardSize, boardSize], true);\n                    // any spot in bool 3x3 that already has a number, set to false\n                    tests = this.markOccupiedSquares(tests, square);\n                    // foreach 3 rows\n                    // if a row has that number, set false to 3 squares in that row\n                    tests = this.markRowXrays(tests, square, candidate);\n                    // foreach 3 cols\n                    // if a col has that number, set false to 3 squares in that col\n                    tests = this.markColXrays(tests, square, candidate);\n                    // does bool array have exactly 1 true? if so, square solved\n                    // write the value to this.board\n                    const solvedSquare = this.getSolvedSquare(tests, square, candidate);\n                    if (solvedSquare) {\n                        const solvedRow = solvedSquare.getRow();\n                        const solvedCol = solvedSquare.getCol();\n                        hintMode || (this.board[solvedRow][solvedCol] = candidate);\n                        return solvedSquare;\n                    }\n                }\n            }\n        }\n        getSolvedSquare(tests, square, candidate) {\n            let count = 0;\n            // Keep in mind that $square is the top left square of the box, and not the $solvedSquare.\n            let solvedRow = square.getRow();\n            let solvedCol = square.getCol();\n            for (let i = 0; i < boardSquare; i++)\n                for (let j = 0; j < boardSquare; j++) tests[i][j] && (count++, solvedRow += i, solvedCol += j);\n            return count === 1 ? new SudokuSquare(solvedRow, solvedCol, candidate) : false;\n        }\n        throwDuplicateNumberError() {\n            window.alert(\"Bad puzzle. A duplicate number was found.\");\n            // Using throw here because JS doesn`t appear to have the PHP equivalent of break 2 to break out of nested loops and functions\n            throw \"Bad puzzle. A duplicate number was found.\";\n        }\n        // If the 3 rows going through this box have the candidate number, mark the squares in those rows as false.\n        markRowXrays(tests, square, candidate) {\n            let testResults = tests,\n                i, j;\n            const row = square.getRow();\n            const rowOffset = Math.floor(row / boardSquare) * boardSquare;\n            for (i = 0 + rowOffset; i < boardSquare + rowOffset; i++)\n                for (j = 0; j < boardSize; j++)\n                    if (this.board[i][j] === candidate)\n                        for (let k = 0; k < boardSquare; k++) testResults[i - rowOffset][k] = false;\n            return testResults;\n        }\n        markColXrays(tests, square, candidate) {\n            let testResults = tests,\n                i, j;\n            const col = square.getCol();\n            const colOffset = Math.floor(col / boardSquare) * boardSquare;\n            for (i = 0 + colOffset; i < boardSquare + colOffset; i++)\n                for (j = 0; j < boardSize; j++)\n                    if (this.board[j][i] === candidate) {\n                        for (let k = 0; k < boardSquare; k++) testResults[k][i - colOffset] = false;\n                    }\n            return testResults;\n        }\n        markOccupiedSquares(tests, square) {\n            let testResults = tests,\n                i, j;\n            const row = square.getRow();\n            const col = square.getCol();\n            const rowOffset = Math.floor(row / boardSquare) * boardSquare;\n            const colOffset = Math.floor(col / boardSquare) * boardSquare;\n            for (i = 0 + rowOffset; i < boardSquare + rowOffset; i++)\n                for (j = 0 + colOffset; j < boardSquare + colOffset; j++)\n                    if (this.board[i][j]) testResults[i - rowOffset][j - colOffset] = false;\n            return testResults;\n        }\n        getLegalMoves() {\n            let numberOfSolutionsSoFar = 0;\n            let legalMoves = new LegalMoves();\n            const currentSudoku = this;\n            if (numberOfSolutionsSoFar > 500 || !this.puzzleIsValid() || this.puzzleIsSolved()) return legalMoves;\n            // foreach boardsquare\n            for (let square of currentSudoku.getAllSquares()) {\n                // if square is empty\n                if (square.getValue() === 0) {\n                    // for each possible number 1-9\n                    for (let i = 1; i <= boardSize; i++) {\n                        const row = square.getRow();\n                        const col = square.getCol();\n                        let nextSudoku;\n                        currentSudoku.isLegalMove(row, col, i) && (\n                            // create new Sudoku\n                            nextSudoku = new SudokuBoard(), nextSudoku.parseString(currentSudoku.getString()), nextSudoku.makeMove(row, col, i), nextSudoku.puzzleIsSolved() && numberOfSolutionsSoFar++, legalMoves.addMove(nextSudoku.getString()));\n                    }\n                }\n            }\n            return legalMoves;\n        }\n        puzzleIsSolved() {\n            for (let i = 0; i < boardSize; i++)\n                for (let j = 0; j < boardSize; j++)\n                    if (this.board[i][j] === 0) return false;\n            return true;\n        }\n        getAllSolutions() {\n            if (!this.puzzleIsValid()) return (this.throwDuplicateNumberError(), 0);\n            if (this.puzzleIsSolved()) return 1;\n            const initialRecursionTracker = new RecursionTracker();\n            const initialSudoku = new SudokuBoard();\n            initialSudoku.setBoard(SudokuBoard.cloneBoard(this.board));\n            // Solve using simple logical techniques first. Filling in a couple of the first squares really helps speed up recursion for certain difficult puzzles.\n            const solvedEarly = initialSudoku.solveLogically();\n            initialRecursionTracker.setSudokuToCheck(initialSudoku);\n            if (solvedEarly) return (initialRecursionTracker.addSolution(initialSudoku), initialRecursionTracker);\n            const finalRecursionTracker = this.solveRecursively(initialRecursionTracker);\n            return finalRecursionTracker;\n        }\n        solveRecursively(recursionTracker) {\n            // Benchmark History, RECURSION_LIMIT = 50,000, board = Testing Solution Count 2, DESKTOP-PC, Chrome\n            // 2508  ms initially\n            // 2186  ms added/refactored getTrueKey\n            // 1519  ms added/refactored cloneBoard\n            //  789  ms added/refactored squareIsSolved\n            //  298  ms added/refactored setBoard\n            //  170  ms commented out RegEx in get_legal_move\n            //    0.4ms added return after for loop in solveRecursively\n            //    0.1ms tries to logical solve once before trying to recursive solve\n            // The best way to get speed is to use a combination of iteration (simple logical solving techniques) and recursion. The iteration cuts down on the amount of recursion needed significantly, and recursion checks the rest.\n            const RECURSION_LIMIT = 1000000000;\n            const SOLUTION_LIMIT = 500;\n            if (recursionTracker.getSolutionCount() >= SOLUTION_LIMIT) return recursionTracker;\n            if (recursionTracker.getBoardsCheckedCount() > RECURSION_LIMIT) return (recursionTracker.markEarlyExit(), recursionTracker);\n            const currentSudoku = recursionTracker.getSudokuToCheck();\n            // foreach boardsquare\n            for (let square of currentSudoku.getAllSquares()) {\n                // if square is empty\n                if (square.getValue() === 0) {\n                    // for each possible number 1-9\n                    for (let i = 1; i <= boardSize; i++) {\n                        if (recursionTracker.getBoardsCheckedCount() > RECURSION_LIMIT) return (recursionTracker.markEarlyExit(), recursionTracker);\n                        const row = square.getRow();\n                        const col = square.getCol();\n                        if (currentSudoku.isLegalMove(row, col, i, false)) {\n                            recursionTracker.incrementBoardsChecked();\n                            // create new Sudoku\n                            let nextSudoku = new SudokuBoard();\n                            const board = SudokuBoard.cloneBoard(currentSudoku.board);\n                            nextSudoku.setBoard(board);\n                            // make move\n                            nextSudoku.makeMove(row, col, i);\n                            // propagate forced-moves\n                            if (!nextSudoku.propagate()) continue;\n                            nextSudoku.puzzleIsSolved() ? (recursionTracker.addSolution(nextSudoku), recursionTracker.incrementBoardsChecked()) : (recursionTracker.setSudokuToCheck(nextSudoku), recursionTracker = this.solveRecursively(recursionTracker));\n                        }\n                    }\n                    // This line is super important. I didn't have it and the solver was slow as molasses until I figured this out.\n                    // We should find ONE blank square, find a legal move, then make a recursive solve call using the new board.\n                    // The tree should be expanding DOWNWARDS, not SIDEWAYS.\n                    // This line will prune all the sideways calculations except for trying legal moves in one empty square.\n                    // Find that ONE blank square, try 1-9, then get out.\n                    return recursionTracker;\n                }\n            }\n            return recursionTracker;\n        }\n        static getTrueKey(array) {\n            let count = 0;\n            let trueKey = false;\n            for (let key in array) array[key] && (trueKey = key, count++);\n            return count === 1 ? parseInt(trueKey) : false;\n        }\n        makeEasyPuzzle(freeSquares = 47) {\n            // Optimization history. Run loop 100 times with no early exit.\n            //  900-1450ms\n            //  306- 381ms getLegalMovesForSquare (bitwise) instead of try 100 random numbers\n            //  188- 245ms makeSolvedPuzzle method: 2x \"for\" loops instead of \"for of\" loop\n            let newBoard;\n            let generated = 0;\n            while (true) {\n                newBoard = new SudokuBoard();\n                newBoard.makeSolvedPuzzle();\n                newBoard.deleteSquares(freeSquares); // 47\n                generated++;\n                if (anySolved(newBoard)) continue;\n                const recursionTracker = new RecursionTracker();\n                recursionTracker.setSudokuToCheck(newBoard);\n                const numberOfSolutions = this.solveRecursively(recursionTracker).getSolutionCount();\n                const newBoardCopy = new SudokuBoard();\n                newBoardCopy.parseString(newBoard.getString());\n                const easyToSolve = newBoardCopy.solveLogically();\n                // Check for these two \"bad\" conditions. If true, continue looking for puzzles.\n                // Recursive solve has multiple solutions\n                // Simple solver cannot solve it. Difficulty level too hard for the user.\n                if (numberOfSolutions === 1 && easyToSolve) break;\n            }\n            console.log(generated + \" Puzzle generiert, bis ein \" + difficulty[freeSquares] + \" zu lösendes Puzzle gefunden wurde, das nur eine Lösung hat.\");\n            this.parseString(newBoard.getString());\n        }\n        deleteSquares(toDelete) {\n            let deleted = 0;\n            while (deleted < toDelete) {\n                const row = Helper.getRandomInteger(0, boardSize - 1);\n                const col = Helper.getRandomInteger(0, boardSize - 1);\n                this.board[row][col] && (this.board[row][col] = 0, deleted++);\n            }\n        }\n        makeSolvedPuzzle() {\n            while (!this.puzzleIsSolved()) {\n                newBoard: for (let row = 0; row < boardSize; row++) {\n                    for (let col = 0; col < boardSize; col++) {\n                        const legalMoves = this.getLegalMovesForSquare(row, col);\n                        // Empty arrays are not falsey in JavaScript. Have to be verbose here.\n                        if (legalMoves.length === 0) {\n                            this.restartPuzzle();\n                            break newBoard;\n                        }\n                        const index = Helper.getRandomInteger(0, legalMoves.length - 1);\n                        const value = legalMoves[index];\n                        this.makeMove(row, col, value);\n                    }\n                }\n            }\n        }\n        getLegalMovesForSquare(row, col) {\n            if (this.board[row][col]) return false;\n            // binary representation of candidates\n            // 987654321X\n            // 1 means the # IS a possible candidate, 0 means the # is NOT a possible candidate\n            let candidates = 0b1111111110;\n            for (let i = 0; i < boardSize; i++) {\n                // If i is in row/col/house, set candidate from 1 (possible candidate) to 0 (not possible candidate)\n                // check row\n                candidates &= ~(1 << this.board[row][i]);\n                // check column\n                candidates &= ~(1 << this.board[i][col]);\n                // check house\n                // 1 2 3\n                // 4 5 6\n                // 7 8 9\n                const houseTopLeftRow = Math.floor(row / boardSquare) * boardSquare;\n                const houseTopLeftCol = Math.floor(col / boardSquare) * boardSquare;\n                const houseRow = houseTopLeftRow + Math.floor(i / boardSquare);\n                const houseCol = houseTopLeftCol + (i % boardSquare);\n                candidates &= ~(1 << this.board[houseRow][houseCol]);\n            }\n            let candidatesArray = [],\n                i;\n            for (i = 1; i <= boardSize; i++) candidates & 1 << i && candidatesArray.push(i);\n            return candidatesArray;\n        }\n        // TODO: rename\n        // Credit to harold at codereview.stackexchange.com for this code.\n        // https://codereview.stackexchange.com/questions/239935/javascript-sudoku-recursive-solver\n        // By taking a bitwise approach, it sped up the solve routine considerably.\n        propagate() {\n            // For each row, column and block,\n            // get a mask indicating which values are already present in it.\n            // 0b87654321X\n            // block order is top top top middle middle middle bottom bottom bottom\n            let rowmask = new Int32Array(boardSize),\n                colmask = new Int32Array(boardSize),\n                blockmask = new Int32Array(boardSize),\n                cellmask = new Int32Array(boardGrid),\n                i, j, k, l, m, m1, m2, mask, move, changed = false;\n            for (i = 0; i < boardSize; i++) {\n                for (j = 0; j < boardSize; j++) {\n                    rowmask[i] |= 1 << this.board[i][j];\n                    colmask[j] |= 1 << this.board[i][j];\n                    // | 0 forces integer, no remainder. JavaScript defaults to float, and quietly rounds decimal array indexes.\n                    blockmask[(i / boardSquare | 0) * boardSquare + (j / boardSquare | 0)] |= 1 << this.board[i][j];\n                }\n            }\n            // For each cell, get a mask indicating which values are valid to fill into it.\n            // Excludes zero, as zero is the lack of a value.\n            // For a filled cell, the only value it can have is the value it already has.\n            // For empty cells, the possible values are values that are not already used in the same row/column/block.\n            for (i = 0; i < boardSize; i++) {\n                for (j = 0; j < boardSize; j++) {\n                    mask = rowmask[i] | colmask[j] | blockmask[(i / boardSquare | 0) * boardSquare + (j / boardSquare | 0)];\n                    // invert to take the *unused* values\n                    // 0x3FE = 0011_1111_1110 (bits 1 to 9 are set)\n                    cellmask[i * boardSize + j] = ~mask & 0x3FE;\n                    this.board[i][j] !== 0 && (cellmask[i * boardSize + j] = 1 << this.board[i][j]);\n                }\n            }\n            do {\n                changed = false;\n                // hidden single - only candidate in that house/row/col\n                for (i = 0; i < boardSize; i++) {\n                    m1 = 0;\n                    m2 = 0;\n                    for (j = 0; j < boardSize; j++) {\n                        m = cellmask[i * boardSize + j];\n                        m2 |= m1 & m;\n                        m1 |= m;\n                    }\n                    for (j = 0; j < boardSize; j++) {\n                        m = cellmask[i * boardSize + j];\n                        m &= ~m2;\n                        m !== 0 && (cellmask[i * boardSize + j] = m & -m);\n                    }\n                }\n                for (j = 0; j < boardSize; j++) {\n                    m1 = 0;\n                    m2 = 0;\n                    for (i = 0; i < boardSize; i++) {\n                        m = cellmask[i * boardSize + j];\n                        m2 |= m1 & m;\n                        m1 |= m;\n                    }\n                    for (i = 0; i < boardSize; i++) {\n                        m = cellmask[i * boardSize + j];\n                        m &= ~m2;\n                        m !== 0 && (cellmask[i * boardSize + j] = m & -m);\n                    }\n                }\n                // naked singles - only candidate left in that particular cell\n                // we just filled a cell with the value 'move'\n                // remove that as a possible value from cells in\n                // the same row/column/block\n                for (i = 0; i < boardSize; i++) {\n                    for (j = 0; j < boardSize; j++) {\n                        mask = cellmask[i * boardSize + j];\n                        if (this.board[i][j] !== 0) continue;\n                        if (mask === 0) return false;\n                        if (this.isSingleSetBit(mask)) {\n                            move = this.getSetBitPosition(mask);\n                            this.makeMove(i, j, move);\n                            changed = true;\n                            // we just filled a cell with the value 'move'\n                            // remove that as a possible value from cells in\n                            // the same row/column/block\n                            for (k = 0; k < boardSize; k++) {\n                                cellmask[i * boardSize + k] &= ~(1 << move);\n                                cellmask[k * boardSize + j] &= ~(1 << move);\n                            }\n                            for (k = 0; k < boardSquare; k++)\n                                for (l = 0; l < boardSquare; l++) cellmask[((i / boardSquare | 0) * boardSquare + k) * boardSize + (j / boardSquare | 0) * boardSquare + l] &= ~(1 << move);\n                        }\n                    }\n                }\n            } while (changed);\n            return true;\n        }\n        isSingleSetBit(x) {\n            return x !== 0 && (x & -x) === x;\n        }\n        getSetBitPosition(x) {\n            for (let i = 0; i < 31; i++)\n                if ((x & (1 << i)) !== 0) return i;\n            return -1;\n        }\n    }\n    class RecursionTracker {\n        constructor() {\n            this.numberOfSolutions = 0;\n            this.solutionList = [];\n            this.sudokuToCheck = null;\n            this.boardsChecked = 0;\n            this.earlyExit = false;\n        }\n        getSolutionCount() {\n            return this.solutionList.length;\n        }\n        getSolutionList() {\n            return this.solutionList;\n        }\n        getInfoString() {\n            let string = Helper.addCommasToNumber(this.getBoardsCheckedCount()) + \" Spiele wurden rekursiv geprüft.\\n\\n\";\n            string += this.solutionList.length >= 500 ? \"Suche nach 500 gefundenen Lösungen abgebrochen.\\nDie ersten 500 Lösungen:\\n\" : this.solutionList.length === 1 ? \"Es wurde nur eine Lösung gefunden:\\n\" : \"Es wurden \" + this.solutionList.length + \" Lösungen gefunden:\\n\";\n            this.earlyExit && (string += \"Rekursions-Limit erreicht, Überprüfung vorzeitig beendet.\\n\");\n            for (let solutionString of this.solutionList) string += solutionString + \"\\n\";\n            return string;\n        }\n        getSudokuToCheck() {\n            return this.sudokuToCheck;\n        }\n        getBoardsCheckedCount() {\n            return this.boardsChecked;\n        }\n        markEarlyExit() {\n            this.earlyExit = true;\n        }\n        addSolution(sudoku) {\n            const sudokuStringToCheck = sudoku.getString();\n            this.solutionList.includes(sudokuStringToCheck) || this.solutionList.push(sudokuStringToCheck);\n        }\n        setSudokuToCheck(sudoku) {\n            this.sudokuToCheck = sudoku;\n        }\n        incrementBoardsChecked() {\n            this.boardsChecked++;\n        }\n    }\n    class LegalMoves {\n        constructor() {\n            this.legalMoves = [];\n        }\n        addMove(move) {\n            this.legalMoves.push(move);\n        }\n        getString() {\n            let moveString = \"\";\n            for (let move of this.legalMoves) moveString += move + \"\\n\";\n            return moveString;\n        }\n        count() {\n            return this.legalMoves.length;\n        }\n    }\n    class SudokuSquare {\n        constructor(row, col, innerHTML = 0) {\n            this.row = parseInt(row);\n            this.col = parseInt(col);\n            this.innerHTML = parseInt(innerHTML);\n        }\n        getSquare() {\n            return [this.row, this.col];\n        }\n        getRow() {\n            return this.row;\n        }\n        getCol() {\n            return this.col;\n        }\n        getValue() {\n            return this.innerHTML;\n        }\n        setValue(value) {\n            this.innerHTML = value;\n        }\n    }\n    class SudokuDOM {\n        static displayBoard(sudoku, sudokuSquares, stringBox, sudokuWikiLink, changeSquareColor = true) {\n            const board = sudoku.getBoard();\n            sudokuSquares = this.clearBoard(sudokuSquares, changeSquareColor);\n            for (let row = 0; row < boardSize; row++) {\n                for (let col = 0; col < boardSize; col++) {\n                    const input = sudokuSquares[row][col];\n                    input.classList.remove(\"hint\");\n                    changeSquareColor && (input.disabled = false);\n                    board[row][col] != 0 && (input.innerHTML = board[row][col], changeSquareColor && (input.classList.add(\"imported-square\"), input.disabled = true));\n                }\n            }\n            SudokuDOM.displayString(sudoku, stringBox, sudokuWikiLink);\n        }\n        static displayString(board, stringBox, sudokuWikiLink) {\n            stringBox.value = stringBoxValue = board.getString();\n            sudokuWikiLink.href = \"https://www.sudokuwiki.org/sudoku.htm?bd=\" + board.getString();\n            if (stringBox.value.indexOf(\"0\") == -1) return true;\n        }\n        static clearBoard(sudokuSquares, changeSquareColor = true) {\n            for (let row = 0; row < boardSize; row++) {\n                for (let col = 0; col < boardSize; col++) {\n                    sudokuSquares[row][col].innerHTML = \"\";\n                    changeSquareColor && sudokuSquares[row][col].classList.remove(\"imported-square\");\n                }\n            }\n            return sudokuSquares;\n        }\n        static highlightIllegalMove(obj) {\n            obj.classList.add(\"invalid\");\n            obj.classList.contains(\"highlighted\") && (temp.highlighted = obj, obj.classList.remove(\"highlighted\"));\n            setTimeout(() => {\n                obj.classList.remove(\"invalid\");\n                temp.highlighted && (temp.highlighted === obj && obj.classList.add(\"highlighted\"), temp.highlighted = null);\n            }, 2000);\n        }\n        static highlightHint(obj) {\n            obj.classList.add(\"hint\");\n            setTimeout(() => obj.classList.remove(\"hint\"), 2000);\n        }\n        static hideConsole(consoleBox, algorithm) {\n            consoleBox.style.display = 'none';\n            algorithm.style.display = 'none';\n        }\n    }\n    class Helper {\n        static createArray(length, fill) {\n            var arr = [],\n                args = [...length];\n            !fill && (fill = 0);\n            for (let c = 0; c < args[0]; c++) arr[c] = (args.length > 1 ? Helper.createArray([...args.slice(1)], fill) : fill);\n            return arr;\n        }\n        static getRandomInteger(min, max) {\n            return Math.floor(Math.random() * (max - min + 1) + min);\n        }\n        static addCommasToNumber(x) {\n            return x.toString().replace(new RegExp(\"\\B(?=(\\d{\" + boardSquare + \"})+(?!\\d))\", \"g\"), \",\");\n        }\n        static highlightFinished(arr) {\n            if (arr.length === boardGrid) {\n                gameStatus.finished = 1;\n                let f = document.getElementsByClassName(\"final\");\n                setTimeout(() => {\n                    [...document.getElementsByClassName(\"final\")].forEach(fi => {\n                        fi.classList.remove(\"slip-in\");\n                        fi.style.display = \"none\";\n                    });\n                    for (let i = 0; i < boardGrid; i++) {\n                        children[i].classList.remove(\"victory\");\n                        tds[i].style.animation = \"\";\n                    }\n                }, 5000);\n                for (let i = 0; i < boardGrid; i++) {\n                    children[i].blur();\n                    children[i].disabled = 1;\n                    children[i].classList = \"victory done\";\n                    tds[i].classList.remove(\"highlighted\");\n                    tds[i].classList.remove(\"current-square\");\n                    tds[i].style.animation = `flash-finish ${Helper.getRandomInteger(1000, 1500)}ms ease-in-out ${Helper.getRandomInteger(0, 600)}ms 3`;\n                }\n                [...document.getElementsByClassName(\"final\")].forEach(fi => {\n                    fi.classList.add(\"slip-in\");\n                    fi.style.display = \"block\";\n                });\n            } else {\n                [].forEach.call(arr, e => (e.classList.remove(\"highlighted\"), e.classList.add(\"flash\")));\n                setTimeout(() => children.forEach(e => e.classList.remove(\"flash\")), 1100);\n            }\n        }\n        static checkFinished(e) {\n            if (!e.innerHTML || gameStatus.finished) return;\n            const string = stringBox.value;\n            if (string.indexOf(\"0\") === -1) return Helper.highlightFinished(children);\n            let col, row, i, a, b, c,\n                check = [],\n                highlights = [];\n            for (i = 0; i < boardSquare; i++) {\n                check.push(new Set());\n                highlights.push([]);\n            }\n            e = [...children].indexOf(e);\n            col = e % boardSize;\n            row = Math.floor(e / boardSize);\n            for (i = 0; i < boardSize; i++) {\n                a = children[i * boardSize + col];\n                b = children[i + boardSize * row];\n                c = children[boardSize * (Math.floor(row / boardSquare) * boardSquare + Math.floor(i / boardSquare)) + Math.floor(col / boardSquare) * boardSquare + i % boardSquare];\n                a.innerHTML && (highlights[0].push(a), check[0].add(a.innerHTML));\n                b.innerHTML && (highlights[1].push(b), check[1].add(b.innerHTML));\n                c.innerHTML && (highlights[2].push(c), check[2].add(c.innerHTML));\n            }\n            for (i = 0; i < boardSquare; i++) check[i].size === boardSize && Helper.highlightFinished(highlights[i]);\n        }\n        static highlightPossibilities(e, hl) {\n            if (gameStatus.finished) return;\n            let col, row, squareCol, squareRow, i;\n            e = [...children].indexOf(e);\n            col = e % boardSize;\n            row = Math.floor(e / boardSize);\n            squareRow = Math.floor(row / boardSquare);\n            squareCol = Math.floor(col / boardSquare);\n            for (i = 0; i < children.length; i++) {\n                hl ? (i % boardSize === col || Math.floor(i / boardSize) === row || (Math.floor(Math.floor(i / boardSize) / boardSquare) === squareRow && Math.floor(i % boardSize / boardSquare) === squareCol)) && children[i].classList.add(\"highlighted\") : children[i].classList.remove(\"highlighted\");\n            }\n        }\n        static handleInput(e) {\n            if (gameStatus.finished) return;\n            if (allowed.indexOf(e.keyCode) !== -1) {\n                if (e.target === stringBox) return stringBoxChanged(e);\n            }\n            let key = e.keyCode;\n            let n = document.querySelector(\".current-square\") ? [...tds].indexOf(document.querySelector(\".current-square\")) : currentSquare;\n            if (!/[0-9]{1,2}/.test(n) || gameStatus.finished) return;\n            const c = n;\n            if ([8, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 229].indexOf(key) > -1) {\n                key === 229 && (key = 8);\n                const isImported = children[n].classList.contains(\"imported-square\");\n                !isImported && (children[n].innerHTML = key === 8 ? \"_\" : e.key, setSquareValue({\n                    target: children[n],\n                    keyCode: key,\n                    key: e.key\n                }));\n            }\n            if ([13, 27, 37, 38, 39, 40].indexOf(e.keyCode) === -1) return;\n            e.preventDefault();\n            if (children[n].innerHTML === \"_\") children[n].innerHTML = \"\";\n            tds[n].classList.remove(\"current-square\");\n            Helper.highlightPossibilities(children[n]);\n            while (c === n) {\n                key === 37 ? (n--, n < 0 && (n = tds.length - 1)) : key === 38 ? (n -= boardSize, n === -boardSize ? n = tds.length - 1 : n < 0 && (n += tds.length - 1)) : key === 39 ? (n++, n >= tds.length && (n = 0)) : key === 40 && (n += boardSize, n === tds.length + boardSize - 1 ? n = 0 : n >= tds.length && (n -= tds.length - 1));\n                n < 0 ? n += tds.length : n >= tds.length && (n -= tds.length + boardSize);\n                if (c === n) break;\n            }\n            tds[n].classList.add(\"current-square\");\n            currentSquare = n;\n            key !== 27 && Helper.highlightPossibilities(children[n], 1);\n        }\n        static checkNumberBoxes(e) {\n            const numbers = stringBox.value;\n            const key = e?.key || null;\n            legalValues.split(\"\").forEach(i => {\n                const num = numbers.split(i);\n                numberBoxes[parseInt(i, 16)].style.opacity = num.length > legalValues.length ? 0.3 : 1;\n            });\n            if (key && legalValues.indexOf(key) > -1) {\n                numberBoxes[key].classList.add(\"highlighted\");\n                setTimeout(() => numberBoxes.forEach(e => e.classList.remove(\"highlighted\")), 400);\n            }\n        }\n    }\n    const checkInput = e => {\n        if (gameStatus.finished) return;\n        let input = /[1-9]/.test(e.target.innerHTML) ? {\n            keyCode: e.target.innerHTML.charCodeAt(0),\n            key: e.target.innerHTML\n        } : {\n            keyCode: 8\n        };\n        Helper.handleInput(input);\n    };\n    const resetIfFinished = () => {\n        if (gameStatus.finished === 1) {\n            sudokuDiv.classList.remove(\"victory\");\n            gameStatus.finished = 0;\n            children.forEach(e => e.classList.remove(\"done\"));\n        } else document.querySelector(\".current-square\")?.classList.remove(\"current-square\");\n    }\n    const anySolved = function(game) {\n        let check = [],\n            a, b, c;\n        for (let row = 0; row < boardSize; row++) {\n            check[row] = [new Set(), new Set(), new Set()];\n            for (let col = 0; col < boardSize; col++) {\n                a = game.board[row][col];\n                b = game.board[col][row];\n                c = game.board[Math.floor(row / boardSquare) * boardSquare + Math.floor(col / boardSquare)][Math.floor(row % boardSquare) * boardSquare + col % boardSquare];\n                a && check[row][0].add(a);\n                b && check[row][1].add(b);\n                c && check[row][2].add(c);\n            }\n            if ([check[row][0].size, check[row][1].size, check[row][2].size].indexOf(boardSize) > -1) return true;\n        }\n        return false;\n    };\n    const setSquareValue = function(e) {\n        if (gameStatus.finished) return;\n        const p = [...children].indexOf(e.target);\n        const [row, col] = [Math.floor(p / boardSize), p % boardSize];\n        const isLegal = game1.isLegalMove(row, col, e.target.innerHTML);\n        e.target.classList.remove(\"invalid\");\n        e.target.classList.remove(\"hint\");\n        game1.makeMove(row, col, isLegal ? e.target.innerHTML : 0);\n        // Listen for illegal moves. If illegal, delete input and turn square red fo 2 seconds.\n        isLegal || e.keyCode === 8 ? (SudokuDOM.displayString(game1, stringBox, sudokuWikiLink), Helper.checkFinished(e.target)) : (SudokuDOM.highlightIllegalMove(e.target), setTimeout(() => e.target.innerHTML = \"\", 0));\n        Helper.checkNumberBoxes(e);\n    };\n    const solvePuzzle = function() {\n        const t1 = performance.now();\n        const recursionTracker = game1.getAllSolutions();\n        const t2 = performance.now();\n        document.querySelector(\"#algorithm span\").innerHTML = (t2 - t1).toFixed(1);\n        algorithm.style.display = \"inline-block\";\n        consoleBox.children[0].value = recursionTracker.getInfoString();\n        consoleBox.style.display = \"block\";\n        recursionTracker.getSolutionCount() === 1 && (game1.parseString(recursionTracker.getSolutionList()[0], false), SudokuDOM.displayBoard(game1, sudokuSquares, stringBox, sudokuWikiLink, false));\n        Helper.checkNumberBoxes();\n    };\n    const otherPuzzleChosen = function() {\n        SudokuDOM.hideConsole(consoleBox, algorithm);\n        resetIfFinished();\n        if (puzzlePicker.value.indexOf(\"custom\") > -1) game1.makeEasyPuzzle(puzzlePicker.value.split(\"_\")[1]);\n        else game1.parseString(puzzlePicker.value);\n        SudokuDOM.displayBoard(game1, sudokuSquares, stringBox, sudokuWikiLink);\n        let i = 0;\n        while (children[i].classList.contains(\"imported-square\")) i++;\n        tds[i].classList.add(\"current-square\");\n        Helper.checkNumberBoxes();\n    };\n    const stringBoxChanged = function(e) {\n        if (e.type !== \"change\") return;\n        if (game1.parseString(e.target.value)) {\n            resetIfFinished();\n            SudokuDOM.displayBoard(game1, sudokuSquares, stringBox, sudokuWikiLink);\n            let i = 0;\n            while (children[i].classList.contains(\"imported-square\")) i++;\n            tds[i].classList.add(\"current-square\");\n            Helper.checkNumberBoxes();\n        } else stringBox.value = stringBoxValue;\n    };\n    const enterChildren = e => {\n        const n = [...children].indexOf(e.target);\n        n !== -1 && (currentSquare = n);\n        document.querySelector(\".current-square\")?.classList.remove(\"current-square\");\n        if (!e.target.classList.contains(\"imported-square\")) {\n            e.target.parentElement.classList.add(\"current-square\");\n            !e.target.innerHTML && (e.target.innerHTML = \"_\");\n            Helper.highlightPossibilities(e.target, 1);\n        }\n    };\n    const leaveChildren = e => {\n        if (!e.target.classList.contains(\"imported-square\")) {\n            e.target.innerHTML === \"_\" && (e.target.innerHTML = \"\");\n            Helper.highlightPossibilities(e.target);\n        }\n    };\n    const restartPuzzle = function(e) {\n        SudokuDOM.hideConsole(consoleBox, algorithm);\n        resetIfFinished();\n        game1.restartPuzzle();\n        SudokuDOM.displayBoard(game1, sudokuSquares, stringBox, sudokuWikiLink);\n        let i = 0;\n        while (children[i].classList.contains(\"imported-square\")) i++;\n        tds[i].classList.add(\"current-square\");\n        Helper.checkNumberBoxes(e);\n    };\n    const showHint = function(e) {\n        SudokuDOM.hideConsole(consoleBox, algorithm);\n        if ((e = game1.getHint())) SudokuDOM.highlightHint(sudokuSquares[e.getRow()][e.getCol()]);\n    };\n    const importPuzzle = function() {\n        SudokuDOM.hideConsole(consoleBox, algorithm);\n        let board = prompt(\"Please enter a sequence of 81 numbers, with 0 representing an empty square.\");\n        board = game1.parseString(board);\n        if (board) {\n            resetIfFinished();\n            SudokuDOM.displayBoard(game1, sudokuSquares, stringBox, sudokuWikiLink);\n            let i = 0;\n            while (children[i].classList.contains(\"imported-square\")) i++;\n            tds[i].classList.add(\"current-square\");\n            Helper.checkNumberBoxes();\n        }\n    };\n    const startNewPuzzle = function() {\n        SudokuDOM.hideConsole(consoleBox, algorithm);\n        resetIfFinished();\n        firstStartup && (puzzlePicker.selectedIndex = CUSTOM_PUZZLE_SELECTEDINDEX, firstStartup = 0);\n        const t1 = performance.now();\n        if (puzzlePicker.value.indexOf(\"custom\") > -1) game1.makeEasyPuzzle(puzzlePicker.value.split(\"_\")[1]);\n        else game1.parseString(puzzlePicker.value);\n        const t2 = performance.now();\n        document.querySelector(\"#algorithm span\").innerHTML = (t2 - t1).toFixed(1) + \" ms\";\n        algorithm.style.display = \"inline-block\";\n        SudokuDOM.displayBoard(game1, sudokuSquares, stringBox, sudokuWikiLink, true);\n        let i = 0;\n        while (children[i].classList.contains(\"imported-square\")) i++;\n        tds[i].classList.add(\"current-square\");\n        Helper.checkNumberBoxes();\n    };\n    const propagate = function() {\n        const t1 = performance.now();\n        game1.getLegalMovesForSquare(1, 4);\n        const t2 = performance.now();\n        document.querySelector(\"#algorithm span\").innerHTML = (t2 - t1).toFixed(1);\n        algorithm.style.display = \"inline-block\";\n    };\n    const resizeGrid = function() {\n        const width = Math.floor((Math.min(innerWidth, innerHeight) - 150) / (boardSize + 1));\n        puzzlePicker.style.width = (width * boardSize) + \"px\";\n        for (let i = 0; i < boardGrid; i++) {\n            tds[i].style.width = tds[i].style.height = `${width}px`;\n            children[i].style.width = children[i].style.height = `${width - 6}px`;\n        }\n    }\n    const boardSize = 9;\n    const boardGrid = boardSize ** 2;\n    const boardSquare = Math.sqrt(boardSize);\n    const temp = {};\n    const gameStatus = {};\n    const legalValues = \"123456789abedef\".substring(0, boardSize);\n    const stringBox = document.getElementById(\"string-box\");\n    const sudokuWikiLink = document.getElementById(\"sudoku-wiki-link\");\n    const algorithm = document.getElementById(\"algorithm\");\n    const consoleBox = document.getElementById(\"console\");\n    const puzzlePicker = document.getElementById(\"puzzle-picker\");\n    const newButton = document.getElementById(\"new\");\n    const solveButton = document.getElementById(\"validate\");\n    const restartButton = document.getElementById(\"restart\");\n    const hintButton = document.getElementById(\"hint\");\n    const importButton = document.getElementById(\"import\");\n    const propagateButton = document.getElementById(\"propagate\");\n    const sudokuDiv = document.getElementById(\"sudoku\");\n    const difficulty = {\n        30: \"sehr leicht\",\n        35: \"leicht\",\n        40: \"mittelschwer\",\n        45: \"schwer\",\n        50: \"sehr schwer\"\n    };\n    const input = document.querySelector(\".input-numbers\");\n    const game1 = new SudokuBoard();\n    const sudokuSquares = Helper.createArray([boardSize, boardSize]);\n    const CUSTOM_PUZZLE_SELECTEDINDEX = 3;\n    const numberBoxes = [];\n    var children, tds, stringBoxValue, currentSquare;\n    const allowed = [8, 13, 27, 37, 38, 39, 40, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 96, 97, 98, 99, 100, 101, 102, 103, 104, 105, 229];\n    // Listeners\n    window.addEventListener(\"DOMContentLoaded\", function() {\n        let i = boardSquare - 1;\n        sudokuDiv.innerHTML = \"<tbody>\" + (\"<tr>\" + '<td><span onblur=\"if(legalValues.indexOf(parseInt(this.innerHTML))==-1) this.innerHTML=\\'\\'\"></span></td>'.repeat(boardSize) + \"</tr>\").repeat(boardSize) + \"</tbody>\";\n        for (let o = 1; o <= legalValues.length; o++) input.innerHTML += '<span>' + o + '</span>';\n        input.innerHTML += '<span>&Larr;</span>';\n        [].forEach.call(document.querySelectorAll(\".input-numbers span\"), (e, c) => numberBoxes[c + 1] = e);\n        numberBoxes.forEach(e => e.addEventListener(\"click\", checkInput));\n        [...document.getElementsByClassName(\"final\")].forEach(f => f.innerHTML = 'SOLVED!<br>WELL DONE!');\n        children = document.querySelectorAll(\"#sudoku span\");\n        tds = document.querySelectorAll(\"#sudoku td\");\n        tds[0].classList.add(\"current-square\");\n        while (i < boardSize) {\n            document.querySelectorAll(\"#sudoku tr\")[i].classList.add(\"thick-bottom\");\n            for (let j = 0; j < boardSize; j++) tds[j * boardSize + i].classList.add(\"thick-right\");\n            i += boardSquare;\n        }\n        i = 0;\n        while (children[i].classList.contains(\"imported-square\")) i++;\n        tds[i].classList.add(\"current-square\");\n        resizeGrid();\n        for (let i = 0; i < boardGrid; i++) {\n            children[i].onmouseover = enterChildren;\n            children[i].onmouseout = leaveChildren;\n            let [row, col] = [Math.floor(i / boardSize), i % boardSize];\n            sudokuSquares[row][col] = children[i];\n        }\n        solveButton.addEventListener(\"click\", solvePuzzle);\n        stringBox.addEventListener(\"change\", stringBoxChanged);\n        restartButton.addEventListener(\"click\", restartPuzzle);\n        hintButton.addEventListener(\"click\", showHint);\n        importButton.addEventListener(\"click\", importPuzzle);\n        puzzlePicker.addEventListener(\"change\", otherPuzzleChosen);\n        newButton.addEventListener(\"click\", startNewPuzzle);\n        propagateButton.addEventListener(\"click\", propagate);\n        document.body.addEventListener(\"keydown\", Helper.handleInput);\n        window.addEventListener(\"resize\", resizeGrid);\n        newButton.click();\n        this.focus();\n    });\n})();",
  "ts": "",
  "css": "\n\n@import url('http://fonts.cdnfonts.com/css/dock11');\n\n#propagate, #import {\n    display: none;\n}\n* {\n    scrollbar-width: none;\n    padding: 0;\n    margin: 0;\n}\n\nbody {\n    background-color: #1E1E1E;\n    color: white;\n    margin: 0;\n}\n\nh1 {\n    font-family: Dock11;\n    font-size: 70px;\n}\n\np {\n    margin-block-start: 0;\n    margin-block-end: 0.5em;\n    display: none;\n}\n\na {\n    color: yellow;\n}\n\na:hover {\n    color: orange;\n}\n\na:visited {\n    color: yellow;\n}\n\n#fireworks {\n    background-color: transparent;\n    height: 100vh;\n    width: 100vw;\n    position: absolute;\n    top: 0;\n    left: 0;\n    pointer-events: none;\n}\n\n#string-box {\n    width: 95vw;\n}\n\n#algorithm {\n    display: none;\n}\n\n#console {\n    background-color: transparent;\n    width: 95vw;\n    display: none;\n}\n\n#console textarea {\n    border: none;\n    background-color: transparent;\n    color: #eee;\n    width: 95vw;\n    height: 8em;\n}\n\n.invalid {\n    background-color: red !important;\n}\n\n.imported-square {\n    background-color: lightgray;\n}\n\n.hint {\n    background-color: limegreen;\n}\n\n.highlighted {\n    background-color: #ddd0fe !important;\n}\n\n.flash {\n    animation: flash 1s linear;\n}\n\n.slip-in {\n    animation: slip-in 5s ease;\n}\n\n.jump {\n    animation: jump 0.3s ease;\n}\n\nspan.done:disabled, input.done:disabled {\n    background-color: #fff;\n}\n\n.final {\n    margin: 0;\n    padding: 0;\n    display: none;\n    position: absolute;\n    left: 0;\n    width: 95vw;\n    top: 40vh;\n    background-color: transparent;\n    font-family: Dock11;\n    font-size: 70px;\n    font-weight: 400;\n    z-index: 11;\n    color: #ff0;\n    text-align: center;\n    white-space: nowrap;\n}\n\n#finale {\n    margin-top: 2px;\n    font-size: 86px;\n    letter-spacing: -9.5px;\n    line-height: 83px;\n    z-index: 10;\n    color: #000;\n    margin-left: -5px;\n}\n\n#sudoku {\n    border: none;\n    margin-bottom: 0.5em;\n}\n\n#sudoku tr {\n    display: flex;\n}\n\n#sudoku td {\n    position: relative;\n   text-align: center;\n}\n\n#sudoku input, #sudoku span {\n    display: grid;\n    align-items: center;\n    font-family: Dock11;\n    position: absolute;\n    left: 50%;\n    top: 50%;\n    transform: translate(-50%, -50%);\n    font-size: 3vw;\n    text-align: center;\n    border: none;\n    padding: 0;\n    color: black;\n    border-radius: 5px;\n}\n#sudoku span:not(.imported-square) {\n    background-color: #fff;\n}\n#sudoku .thick-right {\n    margin-right: 5px;\n}\n\n#sudoku .thick-bottom {\n    margin-bottom: 7px;\n}\n\n#sudoku .current-square {\n    background-color: orange;\n}\n\n.input-numbers span {\n    display: inline-block;\n    padding: 5px 10px;\n    margin: 3px 3px 20px 3px;\n    text-align: center;\n    border: #aaa 1px solid;\n    border-radius: 5px;\n}\nbutton, select {\n    margin: 4px;\n    padding: 4px;\n}\n\n@keyframes flash {\n    0% {\n        background-color: #dee;\n    }\n    17% {\n        background-color: #af2;\n    }\n    34% {\n        background-color: #dee;\n    }\n    50% {\n        background-color: #af2;\n    }\n    66% {\n        background-color: #dee;\n    }\n    84% {\n        background-color: #af2;\n    }\n    100% {\n        background-color: #dee;\n    }\n}\n\n@keyframes jump {\n    0% {\n        transform: scale(1) translateY(0)\n    }\n    50% {\n        transform: scale(1.2, 0.8) translateY(10px)\n    }\n    100% {\n        transform: scale(1) translateY(0)\n    }\n}\n\n@keyframes flash-finish {\n    0% {\n        transform: scale(1) translateY(0)\n    }\n    25% {\n        transform: scale(1.2, 0.6) translateY(10px)\n    }\n    50% {\n        transform: scale(0.7, 1.3) translateY(-20px)\n    }\n    65% {\n        transform: scale(1.1, 0.8) translateY(3px)\n    }\n    75% {\n        transform: scale(0.9, 1.1) translateY(-4px)\n    }\n    90% {\n        transform: scale(1.05, 0.95) translateY(0)\n    }\n    100% {\n        transform: scale(1) translateY(0)\n    }\n}\n\n@keyframes slip-in {\n    0% {\n        transform: scale(0.01) translateY(-50%) translateX(-50%)\n    }\n    20% {\n        transform: scale(1) translateY(0) translateX(0)\n    }\n    25% {\n        transform: scale(1.2, 0.6) translateY(10px)\n    }\n    30% {\n        transform: scale(0.7, 1.3) translateY(-20px)\n    }\n    35% {\n        transform: scale(1.1, 0.8) translateY(3px)\n    }\n    38% {\n        transform: scale(0.9, 1.1) translateY(-4px)\n    }\n    41% {\n        transform: scale(1.05, 0.95) translateY(0)\n    }\n    44% {\n        transform: scale(1, 1) translateY(0)\n    }\n    85% {\n        transform: scale(1, 1) translateY(0)\n    }\n    100% {\n        transform: scale(0.01) translateY(-50%) translateX(-50%)\n    }\n}\n\n@keyframes victory {\n    0% {\n        background-color: #fff;\n    }\n    25% {\n        background-color: #0ff;\n    }\n    50% {\n        background-color: #00f;\n    }\n    75% {\n        background-color: #0f0;\n    }\n    100% {\n        background-color: #0ff;\n    }\n}\n\n@keyframes smoothColor {\n    0% {\n        background-color: hsl(0 100% 70%)\n    }\n\n    1% {\n        background-color: hsl(4 100% 70%)\n    }\n\n    2% {\n        background-color: hsl(8 100% 70%)\n    }\n\n    3% {\n        background-color: hsl(12 100% 70%)\n    }\n\n    4% {\n        background-color: hsl(16 100% 70%)\n    }\n\n    5% {\n        background-color: hsl(20 100% 70%)\n    }\n\n    6% {\n        background-color: hsl(24 100% 70%)\n    }\n\n    7% {\n        background-color: hsl(28 100% 70%)\n    }\n\n    8% {\n        background-color: hsl(32 100% 70%)\n    }\n\n    9% {\n        background-color: hsl(36 100% 70%)\n    }\n\n    10% {\n        background-color: hsl(40 100% 70%)\n    }\n\n    11% {\n        background-color: hsl(44 100% 70%)\n    }\n\n    12% {\n        background-color: hsl(48 100% 70%)\n    }\n\n    13% {\n        background-color: hsl(52 100% 70%)\n    }\n\n    14% {\n        background-color: hsl(56 100% 70%)\n    }\n\n    15% {\n        background-color: hsl(60 100% 70%)\n    }\n\n    16% {\n        background-color: hsl(64 100% 70%)\n    }\n\n    17% {\n        background-color: hsl(68 100% 70%)\n    }\n\n    18% {\n        background-color: hsl(72 100% 70%)\n    }\n\n    19% {\n        background-color: hsl(76 100% 70%)\n    }\n\n    20% {\n        background-color: hsl(80 100% 70%)\n    }\n\n    21% {\n        background-color: hsl(84 100% 70%)\n    }\n\n    22% {\n        background-color: hsl(88 100% 70%)\n    }\n\n    23% {\n        background-color: hsl(92 100% 70%)\n    }\n\n    24% {\n        background-color: hsl(96 100% 70%)\n    }\n\n    25% {\n        background-color: hsl(100 100% 70%)\n    }\n\n    26% {\n        background-color: hsl(104 100% 70%)\n    }\n\n    27% {\n        background-color: hsl(108 100% 70%)\n    }\n\n    28% {\n        background-color: hsl(112 100% 70%)\n    }\n\n    29% {\n        background-color: hsl(116 100% 70%)\n    }\n\n    30% {\n        background-color: hsl(120 100% 70%)\n    }\n\n    31% {\n        background-color: hsl(124 100% 70%)\n    }\n\n    32% {\n        background-color: hsl(128 100% 70%)\n    }\n\n    33% {\n        background-color: hsl(132 100% 70%)\n    }\n\n    34% {\n        background-color: hsl(136 100% 70%)\n    }\n\n    35% {\n        background-color: hsl(140 100% 70%)\n    }\n\n    36% {\n        background-color: hsl(144 100% 70%)\n    }\n\n    37% {\n        background-color: hsl(148 100% 70%)\n    }\n\n    38% {\n        background-color: hsl(152 100% 70%)\n    }\n\n    39% {\n        background-color: hsl(156 100% 70%)\n    }\n\n    40% {\n        background-color: hsl(160 100% 70%)\n    }\n\n    41% {\n        background-color: hsl(164 100% 70%)\n    }\n\n    42% {\n        background-color: hsl(168 100% 70%)\n    }\n\n    43% {\n        background-color: hsl(172 100% 70%)\n    }\n\n    44% {\n        background-color: hsl(176 100% 70%)\n    }\n\n    45% {\n        background-color: hsl(180 100% 70%)\n    }\n\n    46% {\n        background-color: hsl(184 100% 70%)\n    }\n\n    47% {\n        background-color: hsl(188 100% 70%)\n    }\n\n    48% {\n        background-color: hsl(192 100% 70%)\n    }\n\n    49% {\n        background-color: hsl(196 100% 70%)\n    }\n\n    50% {\n        background-color: hsl(200 100% 70%)\n    }\n\n    51% {\n        background-color: hsl(204 100% 70%)\n    }\n\n    52% {\n        background-color: hsl(208 100% 70%)\n    }\n\n    53% {\n        background-color: hsl(212 100% 70%)\n    }\n\n    54% {\n        background-color: hsl(216 100% 70%)\n    }\n\n    55% {\n        background-color: hsl(220 100% 70%)\n    }\n\n    56% {\n        background-color: hsl(224 100% 70%)\n    }\n\n    57% {\n        background-color: hsl(228 100% 70%)\n    }\n\n    58% {\n        background-color: hsl(232 100% 70%)\n    }\n\n    59% {\n        background-color: hsl(236 100% 70%)\n    }\n\n    60% {\n        background-color: hsl(240 100% 70%)\n    }\n\n    61% {\n        background-color: hsl(244 100% 70%)\n    }\n\n    62% {\n        background-color: hsl(248 100% 70%)\n    }\n\n    63% {\n        background-color: hsl(252 100% 70%)\n    }\n\n    64% {\n        background-color: hsl(256 100% 70%)\n    }\n\n    65% {\n        background-color: hsl(260 100% 70%)\n    }\n\n    66% {\n        background-color: hsl(264 100% 70%)\n    }\n\n    67% {\n        background-color: hsl(268 100% 70%)\n    }\n\n    68% {\n        background-color: hsl(272 100% 70%)\n    }\n\n    69% {\n        background-color: hsl(276 100% 70%)\n    }\n\n    99% {\n        background-color: #fff;\n    }\n}\n\n.victory {\n    animation: smoothColor 5s linear;\n}\n",
  "images": "",
  "lastEdit": 1715352232520,
  "created": 1665912412605,
  "size": 76428,
  "assets": ""
}